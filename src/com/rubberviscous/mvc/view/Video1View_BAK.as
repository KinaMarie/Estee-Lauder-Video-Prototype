package com.rubberviscous.mvc.view{	import flash.display.*;	import com.rubberviscous.mvc.model.*;	import com.rubberviscous.mvc.controller.*;	import com.rubberviscous.state.*;	import flash.events.*;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.utils.*;	import flash.geom.*;	import com.greensock.*;	import com.greensock.easing.*;		public class Video1View extends ComponentView	{		private var connection:NetConnection;		private var ns:NetStream;		private var videoURL:String;		private var updatePlayheadTimer:Timer;		private var videoWidth:Number;		private var videoHeight:Number;		private var videoDuration:Number;		private var cuePointArray:Array;		private var xml:XML;		private var netStreamStatus:String;				public function Video1View(aModel:IModel, aController:IController = null)		{			super(aModel, aController);			this.model = aModel; 			this.controller = aController;			//addEventListener(Event.ADDED_TO_STAGE, init)			init();		}				override public function update(event:Event = null):void 		{			//trace("Video1View : update()");			if (model.getVideoView() == this.name) {				if (model.getApplicationState() == model.XMLCOMPLETE) {					videoURL = model.getVideoURL();					xml = model.getXML();					ns.play(videoURL);									} 				else if (model.getApplicationState() == model.VIDEO) {					if (model.getVideoStatus() == VideoState.PLAYING) {						//trace("Video1View : VideoState.PLAYING");						controller.setVideoDuration(videoDuration);						updatePlayheadTimer.start();						if (netStreamStatus == "NetStream.Play.Stop" || netStreamStatus == "NetStream.Buffer.Empty") {							ns.seek(0);						} else {							ns.resume();						}					} else if (model.getVideoStatus() == VideoState.PAUSED) {						ns.pause();						updatePlayheadTimer.stop();					} else if (model.getVideoStatus() == VideoState.SEEK) {						ns.seek(model.getVideoTime());						checkForCuepoints();						/*if (netStreamStatus == "NetStream.Seek.Notify") {							model.setVideoStatus(VideoState.PLAYING);							model.setApplicationState(model.VIDEO);						} */					}				}			} else {				if (model.getApplicationState() == model.VIDEOHOTSPOT) {					ns.pause();					mcPlay.alpha = 1;					updatePlayheadTimer.stop();					TweenMax.to(this, .6, {scaleX:.4, scaleY:.4, onUpdate:updatePosition, onUpdateParams:[this], ease:Quad.easeOut, onComplete:makeDraggable, onCompleteParams:[this]});					this.darkGreyScreen.alpha = 0.4;				}			}		}				private function makeDraggable(aDisplayObject:Sprite=null):void		{			aDisplayObject.addEventListener(MouseEvent.MOUSE_DOWN, startDragHandler);			aDisplayObject.addEventListener(MouseEvent.MOUSE_UP, stopDragHandler);			aDisplayObject.buttonMode = true;		}				private function removeDraggable(aDisplayObject:Sprite=null):void		{			aDisplayObject.removeEventListener(MouseEvent.MOUSE_DOWN, startDragHandler);			aDisplayObject.removeEventListener(MouseEvent.MOUSE_UP, stopDragHandler);			aDisplayObject.buttonMode = false;		}				private function startDragHandler(e:MouseEvent):void		{			//trace("Mouse down")			var rect:Rectangle = new Rectangle(0,0,videoWidth-this.width,videoHeight-this.height);			this.startDrag(false, rect);		}				private function stopDragHandler(e:MouseEvent):void		{			this.stopDrag();		}				private function updatePosition(aDisplayObject:DisplayObject):void		{			aDisplayObject.y = (videoHeight - aDisplayObject.height);		}				public function init(e:Event=null):void		{			this.name = "Video1View";			videoWidth = model.getVideoWidth();			videoHeight = model.getVideoHeight();			//trace("VideoView : init()")			connection = new NetConnection();            connection.connect(null);			ns = new NetStream(connection);			ns.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);			            ns.client = this;            video.attachNetStream(ns);			video.smoothing = true;			updatePlayheadTimer = new Timer(30);			updatePlayheadTimer.addEventListener(TimerEvent.TIMER, updatePlayheadHandler);						mcPlay.addEventListener(MouseEvent.CLICK, fullSizeHandler);						cuePointArray = new Array(); 		}				private function fullSizeHandler(e:MouseEvent):void		{			this.darkGreyScreen.alpha = 0;			removeDraggable(this);			TweenMax.to(this, .6, {scaleX:1, scaleY:1, x:0, y:0, ease:Quad.easeOut, onComplete:function() {				/*controller.setVideoView(this.name);				controller.setVideoStatus(VideoState.PLAYING);*/							}});			controller.setVideoView(this.name);			controller.setVideoStatus(VideoState.PLAYING);			controller.setApplicationState(model.VIDEO);			mcPlay.alpha = 0;			//trace("VideoView : "+this.name);		}				private function updatePlayheadHandler(e:TimerEvent):void		{			controller.setVideoTime(ns.time);			//trace(ns.time);			/*if (Math.round(ns.time) == 4) {				//trace("Cue point reached!")			}*/			//trace("updatePlayheadHandler running")			for (var i:uint;i<xml.cuepoint.length();i++) {				var timeStart:Number = Number(xml.cuepoint[i].@time_start);				var timeEnd:Number = Number(xml.cuepoint[i].@time_end);				//var duration:Number = Number(xml.cuepoint[i].@time_end) - Number(xml.cuepoint[i].@time_start);				//trace(ns.time)				//trace(duration);				if (roundDec(ns.time, 1) == timeStart) {					//trace(xml.cuepoint[i].@action);					controller.setCuepointLabel(xml.cuepoint[i]);					controller.setCuepointXY(new Point(Number(xml.cuepoint[i].@x), Number(xml.cuepoint[i].@y)));					controller.setCuepointName(CuePoint.BEGIN);					controller.setCuepointAction(xml.cuepoint[i].@action);					controller.setApplicationState(model.HOTSPOT);				}				if (roundDec(ns.time, 1) == timeEnd) {					controller.setCuepointName(CuePoint.END);					controller.setApplicationState(model.HOTSPOT);				}			}		}				private function checkForCuepoints():void		{						//trace("XML = "+xml);			/*controller.setCuepointName(CuePoint.RESET);			controller.setApplicationState(model.HOTSPOT);*/			var time:Number = model.getVideoTime();			for (var i:uint;i<xml.cuepoint.length();i++) {								var timeStart:Number = Number(xml.cuepoint[i].@time_start);				var timeEnd:Number = Number(xml.cuepoint[i].@time_end);				if (roundDec(time, 1) >= timeStart && roundDec(time, 1) <= timeEnd) {					controller.setCuepointLabel(xml.cuepoint[i]);					controller.setCuepointXY(new Point(Number(xml.cuepoint[i].@x), Number(xml.cuepoint[i].@y)));					controller.setCuepointName(CuePoint.BEGIN);					controller.setCuepointAction(xml.cuepoint[i].@action);					controller.setApplicationState(model.HOTSPOT);					//trace("CUEPOINT EXISTS!!!!!!!!!! = "+xml.cuepoint[i])					trace("showing cue point")					break;				} else {					controller.setCuepointName(CuePoint.END);					controller.setApplicationState(model.HOTSPOT);					trace("Hiding cue point")				}			}		}				private function roundDec(numIn:Number, decimalPlaces:int):Number {			var nExp:int = Math.pow(10,decimalPlaces) ; 			var nRetVal:Number = Math.round(numIn * nExp) / nExp			//trace(nRetVal);			return nRetVal;		}				private function netStatusHandler(event:NetStatusEvent):void {			trace("VideoView : netStatusHandler = "+event.info.code)			netStreamStatus = event.info.code;			switch (event.info.code) {                case "NetStream.Play.StreamNotFound":                    //trace("Stream not found: " + videoURL);                    break;				case "NetStream.Play.Start":					//trace("playback has started");					controller.setVideoStatus(VideoState.PLAYING);					controller.setApplicationState(model.VIDEO);										break;				case "NetStream.Play.Stop":					controller.setVideoStatus(VideoState.STOPPED);					controller.setApplicationState(model.VIDEO);					break;				case "NetStream.Seek.Notify":					model.setVideoStatus(VideoState.PLAYING);					model.setApplicationState(model.VIDEO);					break;            }        }		/*private function metaDataHandler(infoObject:Object):void {		    //trace("metadata: duration=" + infoObject.duration);			controller.setVideoDuration(infoObject.duration);		}*/		public function onMetaData(info:Object):void { 						trace("Video1View onMetaData fired");			videoDuration = info.duration;			controller.setVideoDuration(info.duration);						/*var cuepoints = info.cuePoints;			var all: String;						for( all in cuepoints )			{				//trace( all + ' : ' + cuepoints[ all ].time +'\n')				cuePointArray.push(cuepoints[ all ].time);			}			controller.setCuePoints(cuePointArray);*/			/*for (var j:uint;j<xml.cuepoint.length();j++) {				//trace(xml.cuepoint[j].@time_start);				cuePointArray.push(Number(xml.cuepoint[j].@time_start));			}			controller.setCuePoints(cuePointArray);*/			//trace("controller.setApplicationState(model.METADATARECEIVED);")			controller.setApplicationState(model.METADATARECEIVED);        }				public function onCuePoint(info:Object):void {			/*trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);			if (info.name == CuePoint.SEEPRODUCTBEGIN) {				//trace(info.name);				controller.setCuepointName(CuePoint.SEEPRODUCTBEGIN);				controller.setApplicationState(model.HOTSPOT);			} else if (info.name == CuePoint.SEEPRODUCTEND) {				controller.setCuepointName(CuePoint.SEEPRODUCTEND);				controller.setApplicationState(model.HOTSPOT);			} else if (info.name == CuePoint.LIUWENBIOBEGIN) {				controller.setCuepointName(CuePoint.LIUWENBIOBEGIN);				controller.setApplicationState(model.HOTSPOT);			} else if (info.name == CuePoint.LIUWENBIOEND) {				controller.setCuepointName(CuePoint.LIUWENBIOEND);				controller.setApplicationState(model.HOTSPOT);			} else if (info.name == CuePoint.VIDEOBEGIN) {				controller.setCuepointName(CuePoint.VIDEOBEGIN);				controller.setApplicationState(model.HOTSPOT);			} else if (info.name == CuePoint.VIDEOEND) {				controller.setCuepointName(CuePoint.VIDEOEND);				controller.setApplicationState(model.HOTSPOT);			}*/		}				/*public function onXMPData(infoObject:Object):void 		{             trace("onXMPData Fired\n");              //trace("raw XMP =\n");              //trace(infoObject.data);             var cuePoints:Array = new Array();             var cuePoint:Object;             var strFrameRate:String;             var nTracksFrameRate:Number;             var strTracks:String = "";             var onXMPXML = new XML(infoObject.data);             // Set up namespaces to make referencing easier             var xmpDM:Namespace = new Namespace("http://ns.adobe.com/xmp/1.0/DynamicMedia/");             var rdf:Namespace = new Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");             for each (var it:XML in onXMPXML..xmpDM::Tracks)             {                  var strTrackName:String = it.rdf::Bag.rdf::li.rdf::Description.@xmpDM::trackName;                  var strFrameRateXML:String = it.rdf::Bag.rdf::li.rdf::Description.@xmpDM::frameRate;                  strFrameRate = strFrameRateXML.substr(1,strFrameRateXML.length);                  nTracksFrameRate = Number(strFrameRate);                   strTracks += it;             }             var onXMPTracksXML:XML = new XML(strTracks);             var strCuepoints:String = "";             for each (var item:XML in onXMPTracksXML..xmpDM::markers)             {                 strCuepoints += item;             }             trace("XMP cue point = "+strCuepoints);         }*/				public function transitionIn():void		{		}				public function transitionOut():void		{		}						public function controllerSetApplicationState(aApplicationState:String):void		{			controller.setApplicationState(aApplicationState);		}	}}/*class CustomClient {    public function onMetaData(info:Object):void {        trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate);    }    public function onCuePoint(info:Object):void {        //trace("cuepoint: time=" + info.time + " name=" + info.name + " type=" + info.type);    }}*/